# 数据库查询优化指南

## 概述

本文档提供了在ManagePro系统中进行数据库查询优化的最佳实践和指导原则。通过遵循这些指南，可以显著提升应用程序的性能和用户体验。

## 1. 索引优化

### 1.1 索引策略

#### 单列索引
- 为经常用于WHERE条件的字段添加索引
- 为外键字段添加索引
- 为排序字段添加索引

```python
# 示例：为生产记录模型添加索引
class ProductionRecord(db.Model):
    date = db.Column(db.Date, nullable=False, index=True)  # 查询条件
    factory_id = db.Column(db.Integer, db.ForeignKey('department.id'), index=True)  # 外键
    material_name = db.Column(db.String(100), nullable=False, index=True)  # 筛选条件
    created_at = db.Column(db.DateTime, default=datetime.utcnow, index=True)  # 排序字段
```

#### 复合索引
- 为多字段查询条件创建复合索引
- 索引字段顺序很重要：选择性高的字段在前

```python
# 示例：复合索引
class MaterialTransaction(db.Model):
    __table_args__ = (
        db.Index('idx_factory_date', 'factory_id', 'date'),
        db.Index('idx_customer_material', 'customer', 'material_name'),
    )
```

### 1.2 索引维护

- 定期分析索引使用情况
- 删除未使用的索引
- 监控索引对写操作的影响

## 2. 查询优化

### 2.1 解决N+1查询问题

#### 使用Eager Loading
```python
# 错误示例：N+1查询
records = ProductionRecord.query.all()
for record in records:
    print(record.factory.name)  # 每次循环都会执行一次查询

# 正确示例：使用joinedload
from sqlalchemy.orm import joinedload

records = ProductionRecord.query.options(
    joinedload(ProductionRecord.factory),
    joinedload(ProductionRecord.team),
    joinedload(ProductionRecord.recorder)
).all()
```

#### 使用统一分页服务
```python
from app.utils.pagination_service import pagination_service

# 使用分页服务自动处理eager loading
query = ProductionRecord.query.options(
    joinedload(ProductionRecord.factory),
    joinedload(ProductionRecord.team)
)

result = pagination_service.paginate_query(
    query,
    ProductionRecord,
    default_sort='created_at',
    allowed_sorts=['date', 'material_name', 'quantity']
)
```

### 2.2 查询条件优化

#### 使用索引友好的查询条件
```python
# 好的做法
query = ProductionRecord.query.filter(
    ProductionRecord.factory_id == factory_id,
    ProductionRecord.date >= start_date,
    ProductionRecord.date <= end_date
)

# 避免的做法
query = ProductionRecord.query.filter(
    ProductionRecord.factory.has(name=factory_name),  # 关联查询
    func.year(ProductionRecord.date) == 2024  # 函数调用
)
```

#### 限制查询结果数量
```python
# 始终使用分页或限制结果数量
query = ProductionRecord.query.limit(100)

# 或使用分页
result = pagination_service.paginate_query(query, ProductionRecord)
```

## 3. 缓存策略

### 3.1 查询结果缓存

#### 使用缓存装饰器
```python
from app.utils.cache_service import cache_service, CACHE_TIMEOUT

@cache_service.cache_query_result('metal_prices', CACHE_TIMEOUT['MEDIUM'])
def get_latest_metal_prices():
    return MetalPrice.query.order_by(MetalPrice.quote_date.desc()).limit(10).all()
```

#### 分页查询缓存
```python
# 在分页查询中启用缓存
result = pagination_service.paginate_query(
    query,
    ProductionRecord,
    use_cache=True,
    cache_timeout=CACHE_TIMEOUT['SHORT']
)
```

### 3.2 缓存失效策略

- 数据变更时自动清除相关缓存
- 定期清理过期缓存
- 监控缓存命中率

```python
# 手动清除模型缓存
cache_service.invalidate_model_cache('ProductionRecord')
```

## 4. 查询监控

### 4.1 启用查询监控

在配置文件中启用查询监控：
```python
class DevelopmentConfig(Config):
    ENABLE_QUERY_MONITORING = True
    SLOW_QUERY_THRESHOLD = 0.5  # 500ms
```

### 4.2 监控指标

- 慢查询数量和比例
- 查询执行时间分布
- 最频繁的查询
- 数据库连接池状态

### 4.3 性能分析

访问 `/query_monitor` 查看：
- 查询统计信息
- 慢查询列表
- 性能报告
- 最近查询记录

## 5. 最佳实践

### 5.1 查询设计原则

1. **最小化数据传输**
   - 只查询需要的字段
   - 使用分页限制结果数量
   - 避免SELECT *

2. **优化JOIN操作**
   - 使用适当的JOIN类型
   - 确保JOIN条件有索引支持
   - 避免过多的JOIN

3. **合理使用子查询**
   - 简单条件优先使用WHERE
   - 复杂逻辑考虑子查询
   - 注意子查询的性能影响

### 5.2 开发规范

1. **查询构建**
   ```python
   # 使用统一的分页服务
   from app.utils.pagination_service import pagination_service
   
   # 构建基础查询
   query = Model.query.options(joinedload(Model.relation))
   
   # 应用筛选条件
   filters = {'field': value}
   query = pagination_service.build_filter_query(query, Model, filters)
   
   # 执行分页查询
   result = pagination_service.paginate_query(query, Model)
   ```

2. **缓存使用**
   ```python
   # 对于相对稳定的数据使用缓存
   @cache_service.cache_query_result('model_list', CACHE_TIMEOUT['LONG'])
   def get_model_list():
       return Model.query.all()
   ```

3. **性能测试**
   - 在开发环境启用查询监控
   - 定期检查慢查询日志
   - 对关键查询进行性能测试

### 5.3 常见问题和解决方案

#### 问题1：查询速度慢
**解决方案：**
- 检查是否有适当的索引
- 使用EXPLAIN分析查询计划
- 考虑查询重写或分解

#### 问题2：内存使用过高
**解决方案：**
- 使用分页限制结果数量
- 避免一次性加载大量数据
- 使用流式查询处理大数据集

#### 问题3：缓存命中率低
**解决方案：**
- 分析查询模式
- 调整缓存策略
- 优化缓存键生成逻辑

## 6. 性能监控和调优

### 6.1 关键指标

- 平均查询响应时间
- 慢查询数量
- 缓存命中率
- 数据库连接数

### 6.2 调优流程

1. **识别性能瓶颈**
   - 分析慢查询日志
   - 检查系统资源使用
   - 监控用户反馈

2. **制定优化方案**
   - 索引优化
   - 查询重写
   - 缓存策略调整

3. **实施和验证**
   - 在测试环境验证
   - 监控性能指标变化
   - 收集用户反馈

4. **持续监控**
   - 定期检查性能指标
   - 及时发现新的性能问题
   - 不断优化和改进

## 7. 工具和资源

### 7.1 内置工具

- **分页服务**: `app.utils.pagination_service`
- **缓存服务**: `app.utils.cache_service`
- **查询监控**: `app.utils.query_monitor`

### 7.2 外部工具

- SQLite Browser：数据库查看和分析
- Redis CLI：缓存管理和监控
- 性能分析工具：如py-spy、memory_profiler

### 7.3 参考资料

- SQLAlchemy官方文档
- Flask-SQLAlchemy文档
- Redis缓存最佳实践
- 数据库性能优化指南

---

**注意**: 本文档会根据系统的发展和新的最佳实践持续更新。建议开发团队定期回顾和更新优化策略。